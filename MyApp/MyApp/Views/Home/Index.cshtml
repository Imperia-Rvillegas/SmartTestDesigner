# ─────────────────────────────────────────────────────────────────────────────
# Workflow: Regression (documentado)
#
# ¿Qué hace?
#   Ejecuta suites de pruebas end-to-end/back-end (vía Maven/Cucumber) en GitHub
#   Actions, permitiendo elegir entorno, navegador, usuario lógico, suite y
#   ejecución en paralelo. Opcionalmente publica los resultados en Xray.
#
# ¿Cómo lanzarlo manualmente?
#   GitHub → Actions → Regression → Run workflow. Rellena los inputs (opcionales):
#     - environment: URL o identificador del entorno (ej. https://qa.miapp.com
#       o qa, staging, prod). Si se deja vacío, la suite debe inferirlo.
#     - suite: nombre EXACTO de la suite (coincide con la clase/runner de tests).
#       Si se deja vacío, se ejecuta la lista completa definida en la matriz.
#     - browser: "edge" o "chrome".
#     - user: usuario lógico preconfigurado en datos de prueba.
#     - sendXrayReport: true/false → si es true, sube resultados a Xray.
#     - parallel: true/false → ejecuta todas las suites de la matriz en paralelo.
#     - runner: self-hosted (por defecto) o ubuntu-latest.
#
# Requisitos previos (repo/organización):
#   - Variable de entorno a nivel de Repo u Org:
#       * XRAY_PROJECT_KEY  → clave del proyecto de Jira/Xray (p.ej. IMP)
#   - Secrets:
#       * XRAY_CLIENT_ID, XRAY_CLIENT_SECRET → credenciales de API de Xray Cloud
#   - Imagen de contenedor disponible en el registro: rvillegasvalera/qa-java24-browsers-v2:latest
#   - El pom.xml debe generar artefactos Cucumber en target/<suite>.json y .html
#
# Consejos de uso:
#   - parallel=true acelera, pero ten en cuenta límites de concurrencia de tu plan
#     de Actions y la capacidad del entorno bajo prueba; ajusta max-parallel si
#     fuera necesario.
#   - Para ejecutar solo una suite: especifica el nombre exacto en "suite".
#   - Para depurar fallos, consulta el artefacto de logs: target/logs/<suite>-<runId>.log
#
# Mantenimiento:
#   - Actualiza la lista de suites en la matriz cuando se añadan/eliminen runners.
#   - La acción mikepenz/xray-action@v3 espera formato cucumber JSON.
#
# Cambios clave (2025-10-14):
#   - parallel ahora usa el booleano real: max-parallel: ${{ inputs.parallel && 100 || 1 }}
#   - sendXrayReport condiciona el paso de Xray directamente con if: ${{ inputs.sendXrayReport }}
#   - SEND_XRAY_REPORT en env se normaliza a 'true'/'false' para quienes lo lean desde los tests
# ─────────────────────────────────────────────────────────────────────────────
name: Regression

on:
  # Permite ejecución manual con parámetros (no se dispara en push por defecto)
  workflow_dispatch:
    inputs:
      environment:
        description: 'URL o identificador del entorno de ejecución (ej. qa, staging o pre.dev)'
        required: false
        default: ''
      suite:
        description: 'Suite a ejecutar (si no se indica, se ejecutan todas)'
        required: false
        default: ''
      browser:
        description: 'Navegador para la ejecución'
        required: false
        default: edge
        type: choice
        options: ['edge','chrome']
      user:
        description: 'Usuario utilizado por las pruebas'
        required: false
        default: rvillegas
        type: choice
        options: ['rvillegas','lnieves','staging2','test2']
      sendXrayReport:
        description: 'Enviar el reporte a Xray'
        type: boolean
        default: false
        required: false
      parallel:
        description: 'Ejecutar suites en paralelo'
        type: boolean
        default: false
        required: false
      maxParallel:
        description: 'Número máximo de suites en paralelo (por defecto 10)'
        type: string
        required: false
        default: '10'
      runner:
        description: 'Runner donde ejecutar (self-hosted evita consumir presupuesto de Actions)'
        type: choice
        required: false
        default: self-hosted
        options: ['self-hosted', 'ubuntu-latest']

permissions:
  # Solo lectura del contenido del repo para clonar el código (prudente por seguridad)
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.event.inputs.environment }}-${{ github.ref_name }}
  cancel-in-progress: false

defaults:
  run:
    shell: bash

jobs:
  run-suites:
    # El nombre del job muestra la suite concreta cuando se usa matriz
    name: Ejecutar ${{ matrix.suite }}
    runs-on: ${{ inputs.runner }}
    strategy:
      # No cancela las demás suites si una falla
      fail-fast: false
      max-parallel: ${{ inputs.parallel && fromJSON(inputs.maxParallel) || 1 }}
      matrix:
        # Si suite != '' -> ["suiteElegida"]; si no -> lista completa
        suite: ${{ inputs.suite && inputs.suite != ''
          && fromJSON(format('["{0}"]', inputs.suite))
          || fromJSON('["Articles","AssociatedDimensions","AssociatedUnitArticleFlow","BusinessDimensions","CommercialBudget","Configuration","ForecastAnalysisList","ForecastedMaterialRequirements","ForecastingConcepts","InventoryHealth","InventoryLocations","Inventory","ListOfMaterials","MpsMrpReport","PendingOrders","PotentialDiscontinued","PotentialLaunches","ProcessConfigList","ProductionAlerts","ProductionPlan","ProductionSequencing","Production","ProjectionOfStockNeeds","PurchaseAlerts","PurchasePlan","SalesHistory","Sequencer","SubstituteProducts","SupplierMaterialList","TrackingChangesBetweenCycles","TrackingChangesInTheSameCycle","Unit","Forecasts","Forecasts02","Forecasts03","Forecasts05"]') }}

    # Variables de entorno que consumen los tests/runner
    env:
      ENVIRONMENT: ${{ inputs.environment }}
      # Normalizado a string para quien lo lea desde código/config:
      SEND_XRAY_REPORT: ${{ inputs.sendXrayReport && 'true' || 'false' }}
      BROWSER: ${{ inputs.browser }}
      USER: ${{ inputs.user }}
      SUITE_NAME: ${{ matrix.suite }}
      DOCKER_IMAGE: rvillegasvalera/qa-java24-browsers-v2:latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Instalar Docker (solo si no esta instalado en el entorno)
        if: ${{ inputs.runner == 'self-hosted' }}
        run: |
          if ! command -v docker >/dev/null 2>&1; then
            echo "Docker no encontrado. Instalando docker.io..."
            sudo apt-get update
            sudo apt-get install -y docker.io
            sudo systemctl enable --now docker
          else
            echo "Docker ya está instalado."
          fi

      - name: Ejecutar suite ${{ matrix.suite }}
        run: |
          set -euo pipefail

          HOST_HOME="${HOME:-/home/runner}"
          HOST_M2="${HOST_HOME}/.m2"
          mkdir -p "${HOST_M2}/repository"

          echo "Cache de Maven restaurado: ${{ steps.maven-cache.outputs.cache-hit }}"

          SUITE_NAME="${SUITE_NAME:-}"
          if [ -z "${SUITE_NAME}" ]; then
            echo "::error::SUITE_NAME no está definido en el entorno del job."
            exit 1
          fi

          GITHUB_RUN_ID="${GITHUB_RUN_ID:-0}"
          GITHUB_RUN_NUMBER="${GITHUB_RUN_NUMBER:-0}"

          # Carpeta de logs por suite y ejecución
          mkdir -p target/logs
          LOG_FILE="target/logs/${SUITE_NAME}-${GITHUB_RUN_ID}.log"

          # Ejecutamos Maven dentro del contenedor preparado con navegadores
          set +e
          sudo --preserve-env=ENVIRONMENT,SEND_XRAY_REPORT,BROWSER,USER,SUITE_NAME,GITHUB_RUN_ID,GITHUB_RUN_NUMBER,CI \
            docker run --rm \
            --user "$(id -u):$(id -g)" \
            -v "${PWD}":/workspace \
            -v "${HOST_M2}":/home/runner/.m2 \
            -w /workspace \
            -e ENVIRONMENT \
            -e SEND_XRAY_REPORT \
            -e BROWSER \
            -e USER \
            -e SUITE_NAME \
            -e GITHUB_RUN_ID \
            -e GITHUB_RUN_NUMBER \
            -e HOME=/home/runner \
            -e MAVEN_CONFIG=/home/runner/.m2 \
            -e CI \
            "${DOCKER_IMAGE}" \
            bash -lc "/workspace/scripts/run-maven-suite.sh"
          MVN_EXIT=$?
          set -e

          # Exportamos el código de salida para posibles pasos posteriores/condiciones
          echo "MVN_EXIT=${MVN_EXIT}" >> "${GITHUB_ENV}"

          if [ "${MVN_EXIT}" -ne 0 ]; then
            echo "::error::La ejecución de Maven finalizó con errores. Revisa ${LOG_FILE}."
          fi

      - name: Empaquetar reportes y evidencias
        if: ${{ always() }}
        run: |
          set -euo pipefail

          SUITE="${{ matrix.suite }}"
          ARCHIVE_DIR="target/artifacts"
          ARCHIVE_PATH="${ARCHIVE_DIR}/${SUITE}-report.tar.gz"

          mkdir -p "${ARCHIVE_DIR}"

          shopt -s nullglob dotglob
          files=()

          if [[ -f "target/${SUITE}.html" ]]; then
            files+=("target/${SUITE}.html")
          fi

          if [[ -f "target/${SUITE}.json" ]]; then
            files+=("target/${SUITE}.json")
          fi

          for log_file in target/logs/${SUITE}-*.log; do
            files+=("${log_file}")
          done

          if [[ -d "target/screenshots" ]]; then
            files+=("target/screenshots")
          fi

          if [[ ${#files[@]} -eq 0 ]]; then
            echo "No se encontraron artefactos para empaquetar." >&2
            exit 0
          fi

          tar -czf "${ARCHIVE_PATH}" --ignore-failed-read "${files[@]}"

          du -h "${ARCHIVE_PATH}" || true

      - name: Publicar artefactos
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: resultados-${{ matrix.suite }}
          path: target/artifacts/${{ matrix.suite }}-report.tar.gz
          if-no-files-found: ignore
          retention-days: 14

      - name: Construir metadatos de Test Execution (summary + project + issuetype)
        run: |
          mkdir -p target
          cat > target/xray-testexec.json <<JSON
          {
            "fields": {
              "project": { "key": "${{ vars.XRAY_PROJECT_KEY }}" },
              "issuetype": { "name": "Test Execution" },
              "summary": "${SUITE_NAME} | env=${ENVIRONMENT:-none} | browser=${BROWSER} | user=${USER} | runId=${GITHUB_RUN_ID} | runNumber=${GITHUB_RUN_NUMBER}"
            }
          }
          JSON

      - name: Importar resultados a Xray
        if: ${{ inputs.sendXrayReport }}
        uses: mikepenz/xray-action@v3
        with:
          username: ${{ secrets.XRAY_CLIENT_ID }}
          password: ${{ secrets.XRAY_CLIENT_SECRET }}
          testFormat: "cucumber"
          testPaths: "target/${{ matrix.suite }}.json"
          testExecutionJson: "target/xray-testexec.json"

      - name: Validar resultado de la suite
        if: ${{ always() }}
        run: |
          set -euo pipefail
          LOG_FILE="target/logs/${SUITE_NAME}-${GITHUB_RUN_ID:-0}.log"
          if [[ "${MVN_EXIT:-0}" -ne 0 ]]; then
            echo "La suite ${SUITE_NAME} finalizó con código ${MVN_EXIT}."
            if [[ -f "${LOG_FILE}" ]]; then
              echo "::group::Últimas líneas de ${LOG_FILE}"
              tail -n 200 "${LOG_FILE}"
              echo "::endgroup::"
            fi
            exit "${MVN_EXIT}"
          fi

# ─────────────────────────────────────────────────────────────────────────────
# Solución de problemas (FAQ rápido)
#   • El paso "Importar resultados a Xray" no se ejecuta
#       → Verifica sendXrayReport=true al lanzar el workflow y que existan
#         los secrets XRAY_CLIENT_ID/SECRET y la variable XRAY_PROJECT_KEY.
#   • No se generan los archivos target/<suite>.json/.html
#       → Revisa el pom.xml y la configuración de plugins de Cucumber/Surefire.
#   • Timeouts/errores intermitentes en paralelo
#       → Reduce parallel=false o baja max-parallel; valida capacidad del SUT.
#   • El contenedor no encuentra navegadores
#       → Asegura que la imagen contiene los drivers/browsers correctos.
# ─────────────────────────────────────────────────────────────────────────────